# 小さな CL



## なぜ小さな CLを書くのか？ {#why}

小さく、シンプルな CL とは、次のような CL のことです。

-   **より早くレビューされる。**レビュアが1つの大きな CL をレビューするためにスケジュールに30分のブロックを確保するよりも、5分間でできる小さな CL をレビューを5、6回行う時間を見つける方が簡単です。
-   **より完全にレビューされる。**大きな変更があると、何度も前後に移動しながら分量の多い詳細なコメンタリを行う必要があってストレスがかかる傾向があり、重要な点が見逃されたり抜け落ちてしまう可能性が増します。
-   **バグが入りにくくなる。**より少ない変更しか加えていないため、あなたもレビュアも CL の影響を効果的に考えやすくなり、バグが入り込んでいないか確認しやすくなります。
-   **リジェクトされた場合でも、作業の無駄が少なくて済む。**もし巨大な CL を書いて、その後レビュアがそもそも全体的な方向性が違っていると指摘した場合、あなたはたくさんの作業を無駄にしてしまいます。
-   **よりマージがしやすい。**巨大な CL は作業に長い時間がかかります。そのため、マージするときにたくさんのコンフリクトが生じてしまい、頻繁にマージしなければならなくなります。
-   **より簡単によい設計が行える。**小さいコードの設計やコードの健全性を洗練させるのは、大きな変更を隅々まで洗練させるよりもずっと簡単です。
-   **レビュアのブロッキングを短くできる。**変更全体のうち、自己完結した一部分を送信するようにすれば、現在の CL がレビューされるのを待っている間に、続きのコーディングができるようになります。
-   **ロールバックがよりシンプルになる。**大きな CL は最初の CL 提出時から CL をロールバックするまでの間に更新された複数のファイルを触る可能性が高くなり、ロールバックが複雑になってしまいます (おそらく中間の CL も同時にロールバックしなければならなくなります)。

**レビュアには、ただ CL が大きすぎるというだけの理由で無条件にリジェクトする決定権がある**ということを覚えておいてください。普通は、レビュアはあなたのコントリビューションに感謝し、どうにかして小さな一連の変更に分けられないかとお願いすることになるでしょう。あなたがすでに変更を書き終えた後に分割を行うのにはたくさんの仕事が必要になるかもしれませんし、大きな変更を受け入れるべき理由について議論するのに長い時間が掛かってしまうかもしれません。初めの段階で単に小さい CL を書いた方が簡単です。

## 小さいとはどのくらいか？ {#what_is_small}

In general, the right size for a CL is **one self-contained change**. This means
that:

-   The CL makes a minimal change that addresses **just one thing**. This is
    usually just one part of a feature, rather than a whole feature at once. In
    general it's better to err on the side of writing CLs that are too small vs.
    CLs that are too large. Work with your reviewer to find out what an
    acceptable size is.
-   Everything the reviewer needs to understand about the CL (except future
    development) is in the CL, the CL's description, the existing codebase, or a
    CL they've already reviewed.
-   The system will continue to work well for its users and for the developers
    after the CL is checked in.
-   The CL is not so small that its implications are difficult to understand. If
    you add a new API, you should include a usage of the API in the same CL so
    that reviewers can better understand how the API will be used. This also
    prevents checking in unused APIs.

There are no hard and fast rules about how large is "too large." 100 lines is
usually a reasonable size for a CL, and 1000 lines is usually too large, but
it's up to the judgment of your reviewer. The number of files that a change is
spread across also affects its "size." A 200-line change in one file might be
okay, but spread across 50 files it would usually be too large.

Keep in mind that although you have been intimately involved with your code from
the moment you started to write it, the reviewer often has no context. What
seems like an acceptably-sized CL to you might be overwhelming to your reviewer.
When in doubt, write CLs that are smaller than you think you need to write.
Reviewers rarely complain about getting CLs that are too small.

## 大きな CL はどのようなときに認められるのか？ {#large_okay}

There are a few situations in which large changes aren't as bad:

-   You can usually count deletion of an entire file as being just one line of
    change, because it doesn't take the reviewer very long to review.
-   Sometimes a large CL has been generated by an automatic refactoring tool
    that you trust completely, and the reviewer's job is just to sanity check
    and say that they really do want the change. These CLs can be larger,
    although some of the caveats from above (such as merging and testing) still
    apply.

### ファイルを分割する {#splitting-files}

Another way to split up a CL is by groupings of files that will require
different reviewers but are otherwise self-contained changes.

For example: you send off one CL for modifications to a protocol buffer and
another CL for changes to the code that uses that proto. You have to submit the
proto CL before the code CL, but they can both be reviewed simultaneously. If
you do this, you might want to inform both sets of reviewers about the other CL
that you wrote, so that they have context for your changes.

Another example: you send one CL for a code change and another for the
configuration or experiment that uses that code; this is easier to roll back
too, if necessary, as configuration/experiment files are sometimes pushed to
production faster than code changes.

## リファクタリングを分離する {#refactoring}

It's usually best to do refactorings in a separate CL from feature changes or
bug fixes. For example, moving and renaming a class should be in a different CL
from fixing a bug in that class. It is much easier for reviewers to understand
the changes introduced by each CL when they are separate.

Small cleanups such as fixing a local variable name can be included inside of a
feature change or bug fix CL, though. It's up to the judgment of developers and
reviewers to decide when a refactoring is so large that it will make the review
more difficult if included in your current CL.

## 関連するテストコードを同じ CL の中に含める {#test_code}

Avoid splitting test code into a separate CL. Tests validating your code
modifications should go into the same CL, even if it increases the code line
count.

However, <i>independent</i> test modifications can go into separate CLs first,
similar to the [refactorings guidelines](#refactoring). That includes:

*   validating pre-existing, submitted code with new tests.
*   refactoring the test code (e.g. introduce helper functions).
*   introducing larger test framework code (e.g. an integration test).

## ビルドを壊さない {#break}

If you have several CLs that depend on each other, you need to find a way to
make sure the whole system keeps working after each CL is submitted. Otherwise
you might break the build for all your fellow developers for a few minutes
between your CL submissions (or even longer if something goes wrong unexpectedly
with your later CL submissions).

## 十分小さくできない {#cant}

Sometimes you will encounter situations where it seems like your CL *has* to be
large. This is very rarely true. Authors who practice writing small CLs can
almost always find a way to decompose functionality into a series of small
changes.

Before writing a large CL, consider whether preceding it with a refactoring-only
CL could pave the way for a cleaner implementation. Talk to your teammates and
see if anybody has thoughts on how to implement the functionality in small CLs
instead.

If all of these options fail (which should be extremely rare) then get consent
from your reviewers in advance to review a large CL, so they are warned about
what is coming. In this situation, expect to be going through the review process
for a long time, be vigilant about not introducing bugs, and be extra diligent
about writing tests.

Next: [レビュアのコメントの扱い方](handling-comments.md)
